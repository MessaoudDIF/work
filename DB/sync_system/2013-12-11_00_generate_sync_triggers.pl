#!/usr/bin/env perl

=head1 NOTES

Generates mssql triggers for the PODB synchronization (export-only, current)
system. Also prints table ids. Configuration file contents are appended to the
bottom of this script for simplicity.

=head1 Future Items/Notes:

Transfers for between stores
Pessoa - Have to sync pessoa for stores like Metro Mutts - two stores running
standalone sharing customers.  Would want to run as one for Frequent Buyer
Purposes.
Fin_Lancamento - IDLancamento (int) ; to collect payment information.
CashRegMov - IDCashRegMov (int) ; to collect movements like cash withdrawel
from the cash registers.  This is a sum table;  
Online, cash registers should auto close/reconcile with 24 hour local
clock.
CashRegister - IDCashRegister (int) ; to get cash registers for CashRegMov
records.
CashRegLog - IDCashRegLog (int) ; Also for CashRegMov support to tell how
money gets broken down ; cash, check, ...
CustomerCredit - IDCustomerCredit (int) ; Store credits.
Ent_CustomerDiscount - IDTipoPessoa (int) and IDGroup (int) ; Is this needed?
Believe it is for customer group discounts.  If that's all, leave out and make
reenter online.

=cut

use Modern::Perl;
use Config::General;
use Data::Dumper;

say q{
set xact_abort on;
go
begin tran;

/*
 * Trigger-based system to synchronize data with podb
 *
 * This sql was autogenerated by 2013-12-11_00_generate_sync_triggers.pl
 * Do not make direct changes to this sql file; modify the sql generator
 * instead.
 *
 * + Rolled out to Petland Fairless Hills server Fri Dec 20, 2013, at ~11:45 PST.
 * + Rolled back on Petland Fairless Hills server shortly after due to
 *   ARITHABORT issue (see below).
 
Tables:
    Model - IDModel (int)
    Inventory - StoreID (int), ModelID (int)
    Invoice - IDPreSale (int)
    InventoryMov - IDInventoryMov (int)
    Pessoa - IDPessoa (int)
    Store - IDStore (int)
    Barcode - IDBarcode (char(20))    

Design ideas for recording changes:
    A) Add a ChangedOn column to every table that is synced.
       Then when you export changed data, reset ChangedOn to null.
       Unfortunately wont work out of hte box for deletes.
        -- alter table Model add ChangedOn datetimeoffset null;
        -- create index Model_ChangedOn on Model (ChangedOn) where ChangedOn is not null;
    B) Single-table sync
        -- TableKeyNames varchar(max) not null,
        -- If pipe delimited, must escape pipes for keys that might have them.
        -- TableKeyValues varchar(max) not null,    
    C) Multiple-table sync (see code below).
    D) Trigger could write a metadata language, e.g.:
       DELETE FROM <table> where firstPK = 34243 and SecondPK = 'efiwfes'

There are two options for reading the changes table and generating queries:
    A) perl on the podb side (easy)
    B) mssql SP (difficult)

 */



create table SyncBatches (
    IDSyncBatch int not null identity(0,1) primary key,
    SynchronizedOn datetimeoffset not null default current_timestamp
);

-- The special 0-value batch indicates that it has not been exported yet.
-- Since it's so important to the table, I'm including it inline here with
-- the table definition.
set identity_insert SyncBatches on;
insert into SyncBatches (IDSyncBatch, SynchronizedOn)
    values (0, '1010-10-10 10:10:10');
set identity_insert SyncBatches off;

-- tinyint goes from 0 to 255, that should be enough for the tables we want.
create table SyncTables (
    IDSyncTable tinyint primary key,
    TableName varchar(max) not null
);

-- We don't use a "change type" to indicate whether it's 
-- an insert, update, or delete, because one could easily
-- have all three within a single update window, and only
-- the most recent one matters, so we determine which type
-- it is programatically by comparing with podb.
create table SyncChanges (
    IDSyncChange int not null identity(1,1) primary key,
    
    -- Change to enum or table reference?
    IDSyncTable tinyint not null references SyncTables(IDSyncTable),
    
    -- Alternative to separate key table, pipe delimited.
    KeyValues varchar(max) not null,
    
    -- When it was most *recently* changed. Sync will not be fast
    -- enough for seconds to matter, and this only takes 4 bytes,
    -- so we'll go with the small type. 
    ChangedOn smalldatetime not null,
    
    -- 0 means it hasn't been exported yet.
    IDSyncBatch int not null
        references SyncBatches(IDSyncBatch)
        default 0
);

-- This was originally a functional index with "where IDSyncBatch = 0"; however,
-- that resulted in this error: "MERGE failed because the following SET options
-- have incorrect settings: 'ARITHABORT'." since MainRetail turns off the
-- ARITHABORT setting.
create index SyncChanges_TableAndBatch on SyncChanges (IdSyncTable, IDSyncBatch);


go



};

my $conf = Config::General->new(
    -String => do {local $/; <DATA>},
    -MergeDuplicateBlocks => 1,
);
my %config = $conf->getall;
my $table_root = $config{table};
my @table_names = sort keys %$table_root;
my $sync_tables_count = 0;
my @sync_tables_values;

for my $table_name (@table_names) {
    say qq{if object_id(N'Sync$table_name') is not null }
      . qq{drop trigger Sync$table_name;};
}
say "go";

my @trigger_sql;
for my $table_name (@table_names) {
    my $table_hash = $table_root->{$table_name};
    my $keys = $table_hash->{keys};
    
    # Make all keys into arrays for consistency, even non-composite keys.
    #  -ForceArray doesn't really help because it still doesn't make 
    # the configuration consistent between single-part and multi-part PKs.
    $keys = [$keys] unless ref $keys eq 'ARRAY';
    $sync_tables_count++;
    push @sync_tables_values, "    ($sync_tables_count, '$table_name')";
    push @trigger_sql, gen_trigger($table_name, $keys);
}
my $values_clauses = join(",\n", @sync_tables_values);
my $sync_tables_create = qq{
delete from SyncTables;
insert into SyncTables values
$values_clauses;
go
};
say $sync_tables_create;
say join("\n", @trigger_sql);
print "\n";
say 'commit tran;';


sub gen_trigger {
    my ($table, $keys) = @_;
    
    my @casted_keys = map { "cast($_ as varchar(max))" } @$keys; 
    my $key_combo_select = join(" + '|' + ", @casted_keys);
    
    
    my $sql = qq{
create trigger Sync${table} on $table for insert, update, delete as
    set nocount on;
    
    declare \@IDSyncTable tinyint = (
        select IDSyncTable from SyncTables where TableName = '${table}'
    );
    
    declare \@KeyValueSets table (KeyValues varchar(max));
    -- We don't care whether it was deleted, inserted, or updated.
    -- Union is needed to remove the dupes, and the sort is to help
    -- ensure reproducible operation (processing keys in the same order)
    insert into \@KeyValueSets
        select cast(KeyValues as varchar(max))
        from (
            -- Composite pks will join with a pipe.
            select ${key_combo_select}
            as KeyValues from deleted
            union
            select ${key_combo_select}
            as KeyValues from inserted
        ) keys
        order by KeyValues;

    merge SyncChanges as target
		using (
		    select \@IDSyncTable, KeyValues, current_timestamp
            from \@KeyValueSets
        )
        as source (
            IDSyncTable, KeyValues,  ChangedOn
        )
		on (
		    target.IDSyncTable = source.IDSyncTable
			and target.KeyValues = source.KeyValues
			and target.IDSyncBatch = 0
	    )
		when matched then
			update set ChangedOn = source.ChangedOn
		when not matched then
			insert (IDSyncTable, KeyValues, ChangedOn)
			values (
				source.IDSyncTable,
				source.KeyValues,
				source.ChangedOn
			);
		--output (IDSyncChange) into \@InsertedIDSyncChanges(IDSyncChange);
go};
    return $sql;
}
    

__DATA__
# Displayed in the order of dependency resolution. However, FK constraints could
# be set to deferred until the end of the transaction instead.
# Might need a mapping between "Store" to our licensingdb/podb store system
# Invoice & InventoryMov
<table Store>
    keys=IDStore
</table>
<table Estado>
    keys=IDEstado
</table>
<table Pessoa>
    keys=IDPessoa
</table>
<table Model>
    keys=IDModel
</table>
<table Barcode>
    keys=IDBarcode
</table>
<table Invoice>
    keys=IDPreSale
</table>
<table InventoryMov>
    keys=IDInventoryMov
</table>
# Inventory not currently needed.
#<table Inventory>
#    keys=StoreID
#    keys=ModelID
#</table>
